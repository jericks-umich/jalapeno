enclave {
	include "sgx_tcrypto.h"
	include "sgx_error.h"
	include "../include/status.h"

	trusted {
		// generates a new public and private ec256 key pair, caches the key pair in memory, and persistently stores key pairs on disk
		// the public key is returned for untrusted use, and to identify which private key should be used later on
		public sgx_status_t generate_ec256_key_pair([out] sgx_ec256_public_t* pub);

		// deletes the public/private key pair associated with the input public key, and updates persistent key store on disk
		public sgx_status_t delete_ec256_key_pair([in] sgx_ec256_public_t* pub); 

		// flushes the ec256 public/private keypair associated with the input public key
		// frees memory allocated for key store cache AND removes persistent ec256 key store file on disk 
		public sgx_status_t flush_ec256_key_pair_cache(); 

		// The following functions are for TESTING ONLY
		public sgx_status_t debug_number_ec256_key_pairs([out] int* num_keys);

		// input: 
		//	Pointer to a buffer of encrypted bytes
		//	length of the buffer of encrypted bytes
		//	the public key associated with the private key used for decryption
		// output:
		//	pointer to a buffer of decrypted bytes
		public sgx_status_t debug_decrypt([in,count=len] const uint8_t* ciphertext, uint32_t len, [in] sgx_ec256_public_t* pub, [out,count=len] uint8_t* plaintext);

		// input: 
		//	Pointer to a buffer of plaintext bytes
		//	length of the buffer of plaintext bytes
		//	the public key associated with the private key used for encryption
		// output:
		//	pointer to a buffer of encrypted bytes
		//public sgx_status_t debug_encrypt([in,count=len] const uint8_t* plaintext, uint32_t len, [in] sgx_ec256_public_t* pub, [out,count=len] uint8_t* ciphertext);
		// Note: we didn't talk about this function, so it's commented out, but I put it here just for reference

		// input: 
		//	Pointer to a buffer of plaintext bytes
		//	length of the buffer of plaintext bytes
		//	the public key associated with the private key used for signing
		// output:
		//	pointer to the signature
		public sgx_status_t debug_sign([in,count=len] const uint8_t* plaintext, uint32_t len, [in] sgx_ec256_public_t* pub, [out] sgx_ec256_signature_t* signature);


		// input:
		// 	ciphertext_len      maximum length of ciphertext buffer (should be multiple of 16 bytes (128 bits) greater than plaintext length)
		//                      if the ciphertext is larger than this buffer, this function will return an error
		//	plaintext	          pointer to buffer of plaintext bytes
		//	plaintext_len       length of plaintext buffer
		//	local_pubkey        pointer to the local public key (for looking up its corresponding private key)
		//	remote_pubkey       pointer to the remote public key
		//	server_random       28 random bytes from the server
		//	server_random_len   should be 28
		//	client_random       28 random bytes from the client
		//	client_random_len   should be 28
		// output:
		//	tag	                MAC for the generated ciphertext
		// 	ciphertext          buffer for putting the resulting ciphertext bytes
		public sgx_status_t encrypt_aes_gcm([out,size=16,count=1] sgx_aes_gcm_128bit_tag_t* tag, [out,count=ciphertext_len] uint8_t* ciphertext, uint32_t ciphertext_len, [in,count=plaintext_len] uint8_t* plaintext, uint32_t plaintext_len, [in] sgx_ec256_public_t* local_pubkey, [in] sgx_ec256_public_t* remote_pubkey, [in,count=server_random_len] uint8_t* server_random, uint32_t server_random_len, [in,count=client_random_len] uint8_t* client_random, uint32_t client_random_len);

	};

	untrusted {
		// keep this around for debugging
		int ocall_prints([in, string] const char* str);
		
		// sealing functions
		jalapeno_status_t ocall_store_sealed_keys([in,count=len] const uint8_t* sealed_data, uint32_t len);
		jalapeno_status_t ocall_load_sealed_keys([out,count=len] uint8_t* sealed_data, uint32_t len);

	};
	
};
